import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { db, images, projects, tags, projectTags } from '@/db';
import { v7 as uuidv7 } from 'uuid';
import { z } from 'zod';
import { extractTagsFromMetadata, formatMetadataForDisplay, generateProjectName, extractMetadataFromS3 } from '@/lib/raw-metadata';
import { AuditLogger } from '@/lib/audit-logger';
import { generateAndSaveThumbnails } from '@/lib/thumbnail-generator';
import { eq } from 'drizzle-orm';

// Schema for upload completion
const completeUploadSchema = z.object({
  projectId: z.string().min(1),
  storageKey: z.string().min(1),
  filename: z.string().min(1),
  fileSize: z.number().int().min(1),
  mimeType: z.string().optional(),
});

export const POST = async (request: NextRequest) => {
  const session = await auth.api.getSession({
    headers: request.headers,
  });

  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const userId = session.user.id;

  try {
    const body = await request.json();
    const validated = completeUploadSchema.safeParse(body);

    if (!validated.success) {
      return NextResponse.json(
        { error: 'Invalid request data', details: validated.error },
        { status: 400 }
      );
    }

    const { projectId, storageKey, filename, fileSize, mimeType } = validated.data;

    // Verify project exists and belongs to user
    const [project] = await db
      .select()
      .from(projects)
      .where(eq(projects.id, projectId));

    if (!project || project.userId !== userId) {
      return NextResponse.json({ error: 'Project not found' }, { status: 404 });
    }

    // Verify image record exists
    const [image] = await db
      .select()
      .from(images)
      .where(eq(images.projectId, projectId));

    if (!image) {
      return NextResponse.json({ error: 'Image record not found' }, { status: 404 });
    }

    // Extract real metadata from the uploaded file
    let metadata = null;
    try {
      metadata = await extractMetadataFromS3(storageKey, filename, mimeType || image.mimeType);
      console.log('Extracted metadata for', filename, ':', metadata);
    } catch (metadataError) {
      console.error('Metadata extraction failed:', metadataError);
      // Don't fail the completion if metadata extraction fails
    }

    // Update image record with extracted metadata
    if (metadata) {
      await db
        .update(images)
        .set({
          width: metadata.width,
          height: metadata.height,
          metadata: metadata,
        })
        .where(eq(images.projectId, projectId));

      // Update project name if it's still the default
      if (project.name.startsWith('Project ')) {
        const autoGeneratedName = generateProjectName(metadata);
        await db
          .update(projects)
          .set({ name: autoGeneratedName })
          .where(eq(projects.id, projectId));
      }
    }

    // Generate thumbnails server-side
    try {
      await generateAndSaveThumbnails(
        projectId,
        storageKey,
        mimeType || image.mimeType,
        userId
      );
    } catch (thumbnailError) {
      console.error('Thumbnail generation failed:', thumbnailError);
      // Don't fail the upload if thumbnail generation fails
    }

    // Extract and store tags from metadata
    if (metadata) {
      const extractedTags = extractTagsFromMetadata(metadata);
      for (const tag of extractedTags) {
        const existingTags = await db
          .select()
          .from(tags)
          .where(eq(tags.userId, userId));

        let tagId: string | undefined;
        const existingTag = existingTags.find(t => t.name === tag.name && t.type === tag.type);

        if (existingTag) {
          tagId = existingTag.id;
        } else {
          const [newTag] = await db
            .insert(tags)
            .values({
              id: uuidv7(),
              userId,
              name: tag.name,
              type: tag.type,
            })
            .returning();
          tagId = newTag.id;
        }

        if (tagId) {
          await db.insert(projectTags).values({
            id: uuidv7(),
            projectId,
            tagId,
          });
        }
      }
    }

    // Update project status to completed
    await db
      .update(projects)
      .set({ status: 'completed' })
      .where(eq(projects.id, projectId));

    // Format metadata for display
    const metadataDisplay = metadata ? formatMetadataForDisplay(metadata) : {};

    // Log successful upload completion
    await AuditLogger.logSuccess(
      'upload_complete',
      'image',
      userId,
      projectId,
      {
        filename,
        fileSize,
        mimeType: mimeType || image.mimeType,
        metadata: metadataDisplay,
      },
      request
    );

    return NextResponse.json({
      success: true,
      message: 'Upload completed successfully',
      projectId,
      filename,
      metadata: metadataDisplay,
    });
  } catch (error) {
    console.error('Upload completion error:', error);

    // Log failed upload completion
    try {
      await AuditLogger.logFailure(
        'upload_complete',
        'image',
        error instanceof Error ? error.message : String(error),
        userId,
        undefined,
        {},
        request
      );
    } catch (logError) {
      console.error('Failed to log upload completion error:', logError);
    }

    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
};
